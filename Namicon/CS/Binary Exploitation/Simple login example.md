```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    char password[6];
    int authorised = 0;

    printf("Enter admin password: \n");
    gets(password);

    if(strcmp(password, "pass") == 0)
    {
        printf("Correct Password!\n");
        authorised = 1;
    }
    else
    {
        printf("Incorrect Password!\n");
    }

    if(authorised)
    {
        printf("Successfully logged in as Admin (authorised=%d) :)\n", authorised);
    }else{
		printf("Failed to log in as Admin (authorised=%d) :(\n", authorised);
	}

    return 0;
}
```

```bash
gcc prog.c -o prog -fno-stack-protector -z execstack -no-pie -m32
```

This suffers from a buffer overflow attack. The `password` string is only allocated with 6 characters, which is 6 bytes. It uses `gets`, which writes data into the specified buffer, regardless of input size. And the password itself has been hardcoded into the software.

What we can do is try inputing more characters than the buffer can handle, but that will result in a segfault and crash the program. The integer `authorised` was initialized after `password`, meaning it lies below (because the stack grows downwards) the password in the stack.

If the `password` buffer overflows, it will overflow into the integer, and since the code only checks if `authorised` is a non-zero value, we can just input more than 6 to 10 characters, which overflows the buffer into `authorised`, which it's set to a non-zero value (depending on which ascii character we used).

We can also do something like this just to automate the exploit process a little bit. The below command will input 6 `a`'s and put an `0x01` to overflow into `authorised` and set it to 1:

```bash
python -c "print('a' * 6 + '\x01')" | ./prog
```

We could also 